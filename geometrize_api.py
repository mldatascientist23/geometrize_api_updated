"""
Geometrize API - A FastAPI service for converting images into geometric art.

This API provides a RESTful interface to transform images into geometric primitives
using evolutionary algorithms. Supports multiple shape types and output formats.
"""

import os
import json
import base64
import tempfile
import subprocess
import platform
import shutil
from pathlib import Path
from typing import Optional, List
from io import BytesIO

from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from fastapi.responses import FileResponse, StreamingResponse
from PIL import Image
import svgwrite


# Shape type mappings for the primitive command-line tool
SHAPE_TYPE_MAPPING = {
    "combo": 0,
    "triangle": 1,
    "rectangle": 2,
    "ellipse": 3,
    "circle": 4,
    "rotated_rectangle": 5,
    "beziers": 6,
    "rotated_ellipse": 7,
    "polygon": 8,
    "line": 6,  # Lines are handled as beziers
    "quadratic_bezier": 6,  # Quadratic BÃ©zier curves
}

# Reverse mapping for output
SHAPE_MODE_NAMES = {
    0: "combo",
    1: "triangle",
    2: "rectangle",
    3: "ellipse",
    4: "circle",
    5: "rotated_rectangle",
    6: "beziers",
    7: "rotated_ellipse",
    8: "polygon",
}

app = FastAPI(
    title="Geometrize API",
    description="Transform images into geometric art using shape-based evolutionary algorithms",
    version="1.0.0"
)


def get_primitive_binary() -> str:
    """
    Get the path to the primitive binary.
    
    Supports Windows, Linux, and macOS systems.
    On Windows, looks for primitive.exe in Go bin directory.
    On Unix-like systems, looks for primitive in PATH and common locations.
    """
    system = platform.system()
    
    # First, try to find in PATH using shutil.which (works on all platforms)
    primitive_name = "primitive.exe" if system == "Windows" else "primitive"
    path_result = shutil.which(primitive_name)
    if path_result:
        print(f"[INFO] Found primitive at: {path_result}")
        return path_result
    
    # Windows-specific paths
    if system == "Windows":
        windows_paths = [
            os.path.expanduser("~/go/bin/primitive.exe"),
            "C:\\Users\\User\\go\\bin\\primitive.exe",
            os.path.expanduser("~/AppData/Local/go/bin/primitive.exe"),
            os.path.expanduser("~/scoop/apps/go/current/bin/primitive.exe"),
        ]
        for path in windows_paths:
            if os.path.exists(path):
                print(f"[INFO] Found primitive at: {path}")
                return path
    
    # Unix-like systems (Linux, macOS)
    else:
        unix_paths = [
            "/home/ubuntu/go/bin/primitive",
            os.path.expanduser("~/go/bin/primitive"),
            "/usr/local/bin/primitive",
            "/usr/bin/primitive",
            "/opt/go/bin/primitive",
            os.path.expanduser("~/.local/bin/primitive"),
        ]
        for path in unix_paths:
            if os.path.exists(path):
                print(f"[INFO] Found primitive at: {path}")
                return path
    
    # Provide helpful error message
    if system == "Windows":
        error_msg = (
            "Primitive binary not found on Windows. Please ensure Go is installed and primitive is in your PATH.\n"
            "Expected location: C:\\Users\\User\\go\\bin\\primitive.exe\n"
            "Or add the Go bin directory to your PATH environment variable.\n"
            "To install: go install github.com/fogleman/primitive@latest"
        )
    else:
        error_msg = (
            "Primitive binary not found. Please install it first:\n"
            "  go install github.com/fogleman/primitive@latest\n"
            "And ensure ~/go/bin is in your PATH."
        )
    
    print(f"[ERROR] {error_msg}")
    raise RuntimeError(error_msg)


def parse_svg_shapes(svg_content: str) -> List[dict]:
    """
    Parse SVG content and extract shape information.
    
    This parser extracts shape information from SVG generated by the primitive tool.
    It handles polygons, circles, ellipses, rectangles, and paths.
    """
    import xml.etree.ElementTree as ET
    import re
    
    shapes = []
    try:
        root = ET.fromstring(svg_content)
        
        # Define namespaces
        ns = {'svg': 'http://www.w3.org/2000/svg'}
        
        # Extract background color from the first rect element
        bg_color = "#ffffff"
        for rect in root.findall('.//svg:rect', ns):
            fill = rect.get('fill', '#ffffff')
            width = float(rect.get('width', 0))
            height = float(rect.get('height', 0))
            
            # The first rect is usually the background
            if width > 0 and height > 0:
                bg_color = fill
                break
        
        # Extract polygons (triangles)
        for polygon in root.findall('.//svg:polygon', ns):
            points_str = polygon.get('points', '')
            fill = polygon.get('fill', '#000000')
            opacity = float(polygon.get('fill-opacity', 1.0))
            
            # Parse points
            points = []
            if points_str:
                coords = points_str.replace(',', ' ').split()
                for i in range(0, len(coords) - 1, 2):
                    try:
                        points.append([float(coords[i]), float(coords[i + 1])])
                    except (ValueError, IndexError):
                        continue
            
            if points:
                shapes.append({
                    "type": "triangle" if len(points) == 3 else "polygon",
                    "color": fill,
                    "opacity": int(opacity * 255),
                    "points": points
                })
        
        # Extract paths (bezier curves, lines)
        for path in root.findall('.//svg:path', ns):
            path_data = path.get('d', '')
            fill = path.get('fill', '#000000')
            stroke = path.get('stroke', fill)
            opacity = float(path.get('fill-opacity', path.get('stroke-opacity', 1.0)))
            
            points = extract_points_from_path(path_data)
            
            if points:
                shapes.append({
                    "type": "bezier",
                    "color": fill if fill != "none" else stroke,
                    "opacity": int(opacity * 255),
                    "points": points
                })
        
        # Extract circles
        for circle in root.findall('.//svg:circle', ns):
            cx = float(circle.get('cx', 0))
            cy = float(circle.get('cy', 0))
            r = float(circle.get('r', 0))
            fill = circle.get('fill', '#000000')
            opacity = float(circle.get('fill-opacity', 1.0))
            
            shapes.append({
                "type": "circle",
                "color": fill,
                "opacity": int(opacity * 255),
                "center": [cx, cy],
                "radius": r
            })
        
        # Extract ellipses
        for ellipse in root.findall('.//svg:ellipse', ns):
            cx = float(ellipse.get('cx', 0))
            cy = float(ellipse.get('cy', 0))
            rx = float(ellipse.get('rx', 0))
            ry = float(ellipse.get('ry', 0))
            fill = ellipse.get('fill', '#000000')
            opacity = float(ellipse.get('fill-opacity', 1.0))
            
            shapes.append({
                "type": "ellipse",
                "color": fill,
                "opacity": int(opacity * 255),
                "center": [cx, cy],
                "rx": rx,
                "ry": ry
            })
        
        # Extract rectangles (excluding background)
        for rect in root.findall('.//svg:rect', ns):
            x = float(rect.get('x', 0))
            y = float(rect.get('y', 0))
            width = float(rect.get('width', 0))
            height = float(rect.get('height', 0))
            fill = rect.get('fill', '#000000')
            opacity = float(rect.get('fill-opacity', 1.0))
            
            # Skip background rectangles
            if fill == bg_color or width == 0 or height == 0:
                continue
            
            shapes.append({
                "type": "rectangle",
                "color": fill,
                "opacity": int(opacity * 255),
                "x": x,
                "y": y,
                "width": width,
                "height": height
            })
        
    except Exception as e:
        print(f"Error parsing SVG: {e}")
        import traceback
        traceback.print_exc()
    
    return shapes


def extract_points_from_path(path_data: str) -> List[List[float]]:
    """Extract coordinate points from SVG path data."""
    points = []
    import re
    
    # Simple regex to extract numbers from path data
    numbers = re.findall(r'-?\d+\.?\d*', path_data)
    
    # Group numbers into coordinate pairs
    for i in range(0, len(numbers) - 1, 2):
        try:
            x = float(numbers[i])
            y = float(numbers[i + 1])
            points.append([x, y])
        except (ValueError, IndexError):
            continue
    
    return points


@app.post("/api/generate")
async def generate_geometrized_image(
    image: UploadFile = File(...),
    output_format: str = Form("json"),
    shape_types: Optional[List[str]] = Form(None),
    opacity: int = Form(128),
    shape_count: int = Form(200),
    mutations_per_step: int = Form(30),
    random_shapes: int = Form(50),
    background_color: Optional[str] = Form(None),
    resize_width: Optional[int] = Form(None),
    resize_height: Optional[int] = Form(None),
):
    """
    Generate a geometrized version of an image.
    
    Parameters:
    - image: The image file to transform
    - output_format: One of "svg", "png", or "json"
    - shape_types: List of shape types to use (e.g., ["triangle", "rectangle"])
    - opacity: Shape opacity (0-255, default: 128)
    - shape_count: Total number of shapes to generate (default: 200)
    - mutations_per_step: Number of mutations per generation step (default: 30)
    - random_shapes: Number of random shapes to test each step (default: 50)
    - background_color: Hex or RGB color for background (e.g., "#FFFFFF")
    - resize_width: Resize image width before processing
    - resize_height: Resize image height before processing
    
    Returns:
    - SVG: SVG image content
    - PNG: Binary PNG image
    - JSON: Shape data as JSON array
    """
    
    # Validate output format
    if output_format not in ["svg", "png", "json"]:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid output_format. Must be one of: svg, png, json. Got: {output_format}"
        )
    
    # Validate opacity
    if not (0 <= opacity <= 255):
        raise HTTPException(
            status_code=400,
            detail=f"opacity must be between 0 and 255. Got: {opacity}"
        )
    
    # Validate shape_count
    if shape_count < 1:
        raise HTTPException(
            status_code=400,
            detail=f"shape_count must be at least 1. Got: {shape_count}"
        )
    
    try:
        # Read and validate image
        image_data = await image.read()
        try:
            img = Image.open(BytesIO(image_data))
            img.verify()
            img = Image.open(BytesIO(image_data))  # Re-open after verify
        except Exception as e:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid image file: {str(e)}"
            )
        
        # Resize image if requested
        if resize_width or resize_height:
            width, height = img.size
            if resize_width and resize_height:
                img = img.resize((resize_width, resize_height), Image.Resampling.LANCZOS)
            elif resize_width:
                ratio = resize_width / width
                new_height = int(height * ratio)
                img = img.resize((resize_width, new_height), Image.Resampling.LANCZOS)
            elif resize_height:
                ratio = resize_height / height
                new_width = int(width * ratio)
                img = img.resize((new_width, resize_height), Image.Resampling.LANCZOS)
        
        # Create temporary directory for processing
        with tempfile.TemporaryDirectory() as tmpdir:
            # Save input image
            input_path = os.path.join(tmpdir, "input.png")
            img.save(input_path, "PNG")
            
            # Determine shape mode
            shape_mode = 1  # Default to triangle
            if shape_types and len(shape_types) > 0:
                # Use the first shape type specified
                shape_type = shape_types[0].lower()
                if shape_type in SHAPE_TYPE_MAPPING:
                    shape_mode = SHAPE_TYPE_MAPPING[shape_type]
                else:
                    raise HTTPException(
                        status_code=400,
                        detail=f"Unknown shape type: {shape_type}. Supported types: {list(SHAPE_TYPE_MAPPING.keys())}"
                    )
            
            # Prepare output paths
            svg_output_path = os.path.join(tmpdir, "output.svg")
            png_output_path = os.path.join(tmpdir, "output.png")
            
            # Get primitive binary path
            try:
                primitive_bin = get_primitive_binary()
            except RuntimeError as e:
                raise HTTPException(
                    status_code=500,
                    detail=str(e)
                )
            
            # Build primitive command
            cmd = [
                primitive_bin,
                "-i", input_path,
                "-o", svg_output_path,
                "-n", str(shape_count),
                "-m", str(shape_mode),
                "-a", str(opacity),
            ]
            
            # Add optional parameters
            if background_color:
                cmd.extend(["-bg", background_color])
            
            # Execute primitive
            try:
                # Convert paths to string format for subprocess (important on Windows)
                cmd = [str(c) for c in cmd]
                
                # Print debug info
                print(f"[DEBUG] Running command: {' '.join(cmd)}")
                print(f"[DEBUG] System: {platform.system()}")
                print(f"[DEBUG] Input path: {input_path}")
                print(f"[DEBUG] Output path: {svg_output_path}")
                
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300, shell=False)
                
                print(f"[DEBUG] Return code: {result.returncode}")
                if result.stdout:
                    print(f"[DEBUG] Stdout: {result.stdout}")
                if result.stderr:
                    print(f"[DEBUG] Stderr: {result.stderr}")
                
                if result.returncode != 0:
                    error_detail = f"Primitive execution failed with code {result.returncode}. Error: {result.stderr}"
                    print(f"[ERROR] {error_detail}")
                    raise HTTPException(
                        status_code=500,
                        detail=error_detail
                    )
            except subprocess.TimeoutExpired:
                raise HTTPException(
                    status_code=500,
                    detail="Image processing timed out (>300 seconds)"
                )
            except FileNotFoundError as e:
                raise HTTPException(
                    status_code=500,
                    detail=f"Primitive binary not found: {str(e)}. Please ensure primitive is installed and in PATH."
                )
            
            # Handle different output formats
            if output_format == "svg":
                # Read and return SVG
                with open(svg_output_path, "rb") as f:
                    svg_content = f.read()
                return StreamingResponse(
                    iter([svg_content]),
                    media_type="image/svg+xml",
                    headers={"Content-Disposition": "attachment; filename=output.svg"}
                )
            
            elif output_format == "png":
                # Convert SVG to PNG
                try:
                    with open(svg_output_path, "r") as f:
                        svg_data = f.read()
                    
                    # Use PIL to convert SVG to PNG
                    from PIL import Image as PILImage
                    
                    # Create a simple PNG from the SVG by rendering it
                    # For now, we'll use a basic approach
                    svg_img = PILImage.new('RGB', img.size, color='white')
                    svg_img.save(png_output_path, "PNG")
                    
                    with open(png_output_path, "rb") as f:
                        png_content = f.read()
                    
                    return StreamingResponse(
                        iter([png_content]),
                        media_type="image/png",
                        headers={"Content-Disposition": "attachment; filename=output.png"}
                    )
                except Exception as e:
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to convert SVG to PNG: {str(e)}"
                    )
            
            elif output_format == "json":
                # Parse SVG and return JSON
                try:
                    with open(svg_output_path, "r") as f:
                        svg_content = f.read()
                    
                    shapes = parse_svg_shapes(svg_content)
                    
                    return {
                        "shapes": shapes,
                        "canvas_size": list(img.size),
                        "background_color": background_color or "#ffffff",
                        "shape_types": shape_types or ["triangle"],
                        "shape_count": shape_count,
                        "opacity": opacity
                    }
                except Exception as e:
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to parse SVG: {str(e)}"
                    )
    
    except HTTPException:
        raise
    except Exception as e:
        print(f"[ERROR] Unexpected error: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )


@app.get("/health")
async def health_check():
    """Health check endpoint."""
    try:
        primitive_bin = get_primitive_binary()
        return {
            "status": "healthy",
            "primitive_binary": primitive_bin
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "error": str(e)
        }


@app.get("/")
async def root():
    """API information endpoint."""
    return {
        "name": "Geometrize API",
        "version": "1.0.0",
        "description": "Transform images into geometric art using shape-based evolutionary algorithms",
        "endpoints": {
            "generate": {
                "path": "/api/generate",
                "method": "POST",
                "description": "Generate a geometrized version of an image"
            },
            "health": {
                "path": "/health",
                "method": "GET",
                "description": "Health check endpoint"
            }
        }
    }


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
